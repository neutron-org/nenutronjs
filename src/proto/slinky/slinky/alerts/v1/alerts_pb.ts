// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file slinky/alerts/v1/alerts.proto (package slinky.alerts.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { CurrencyPair } from "../../types/v1/currency_pair_pb.js";
import { ExtendedCommitInfo } from "../../../tendermint/abci/types_pb.js";

/**
 * Alert defines the basic meta-data necessary for the alerts module to resolve
 * a claim that the price of a CurrencyPair on-chain is deviating from the price
 * off-chain.
 *
 * @generated from message slinky.alerts.v1.Alert
 */
export class Alert extends Message<Alert> {
  /**
   * height represents the height for which the alert is filed.
   *
   * @generated from field: uint64 height = 1;
   */
  height = protoInt64.zero;

  /**
   * signer is the signer of this alert, this is the address that will receive
   * the reward in the case of a positive conclusion, or whose bond will get
   * slashed in the event of a negative conclusion.
   *
   * @generated from field: string signer = 2;
   */
  signer = "";

  /**
   * currency_pair is the currency-pair that this claim asserts is deviating
   * from the price off-chain.
   *
   * @generated from field: slinky.types.v1.CurrencyPair currency_pair = 3;
   */
  currencyPair?: CurrencyPair;

  constructor(data?: PartialMessage<Alert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.Alert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "currency_pair", kind: "message", T: CurrencyPair },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Alert {
    return new Alert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJsonString(jsonString, options);
  }

  static equals(a: Alert | PlainMessage<Alert> | undefined, b: Alert | PlainMessage<Alert> | undefined): boolean {
    return proto3.util.equals(Alert, a, b);
  }
}

/**
 * AlertStatus contains the module specific state for an alert: Has the alert
 * been concluded? What height was the alert submitted, what height should the
 * alert be purged?
 *
 * @generated from message slinky.alerts.v1.AlertStatus
 */
export class AlertStatus extends Message<AlertStatus> {
  /**
   * ConclusionStatus determines whether the alert has been concluded.
   *
   * @generated from field: uint64 conclusion_status = 1;
   */
  conclusionStatus = protoInt64.zero;

  /**
   * SubmissionHeight is the height that the alert was submitted in.
   *
   * @generated from field: uint64 submission_height = 2;
   */
  submissionHeight = protoInt64.zero;

  /**
   * SubmissionTimestamp is the block-timestamp of the block that the alert was
   * submitted in (as a UTC value in Unix time).
   *
   * @generated from field: uint64 submission_timestamp = 3;
   */
  submissionTimestamp = protoInt64.zero;

  /**
   * PurgeHeight is the height at which the alert should be purged.
   *
   * @generated from field: uint64 purge_height = 4;
   */
  purgeHeight = protoInt64.zero;

  constructor(data?: PartialMessage<AlertStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.AlertStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conclusion_status", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "submission_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "submission_timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "purge_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertStatus {
    return new AlertStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertStatus {
    return new AlertStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertStatus {
    return new AlertStatus().fromJsonString(jsonString, options);
  }

  static equals(a: AlertStatus | PlainMessage<AlertStatus> | undefined, b: AlertStatus | PlainMessage<AlertStatus> | undefined): boolean {
    return proto3.util.equals(AlertStatus, a, b);
  }
}

/**
 * AlertWithStatus represents a wrapper around the Alert and AlertStatus
 * objects, this is so that the module specific information about Alerts can be
 * packaged together.
 *
 * @generated from message slinky.alerts.v1.AlertWithStatus
 */
export class AlertWithStatus extends Message<AlertWithStatus> {
  /**
   * alert is the alert that this status corresponds to.
   *
   * @generated from field: slinky.alerts.v1.Alert alert = 1;
   */
  alert?: Alert;

  /**
   * status is the status of the alert.
   *
   * @generated from field: slinky.alerts.v1.AlertStatus status = 2;
   */
  status?: AlertStatus;

  constructor(data?: PartialMessage<AlertWithStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.AlertWithStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alert", kind: "message", T: Alert },
    { no: 2, name: "status", kind: "message", T: AlertStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertWithStatus {
    return new AlertWithStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertWithStatus {
    return new AlertWithStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertWithStatus {
    return new AlertWithStatus().fromJsonString(jsonString, options);
  }

  static equals(a: AlertWithStatus | PlainMessage<AlertWithStatus> | undefined, b: AlertWithStatus | PlainMessage<AlertWithStatus> | undefined): boolean {
    return proto3.util.equals(AlertWithStatus, a, b);
  }
}

/**
 * Signature is a container for a signer address mapped to a signature.
 *
 * @generated from message slinky.alerts.v1.Signature
 */
export class Signature extends Message<Signature> {
  /**
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * @generated from field: bytes signature = 2;
   */
  signature = new Uint8Array(0);

  constructor(data?: PartialMessage<Signature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.Signature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signature {
    return new Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJsonString(jsonString, options);
  }

  static equals(a: Signature | PlainMessage<Signature> | undefined, b: Signature | PlainMessage<Signature> | undefined): boolean {
    return proto3.util.equals(Signature, a, b);
  }
}

/**
 * MultiSigConcluson defines a conclusion that is accompanied by a set of
 * signatures. The signature is defined over the alert UID, status, OracleData,
 * and PriceBound. The signatures are used to verify that the conclusion is
 * valid.
 *
 * @generated from message slinky.alerts.v1.MultiSigConclusion
 */
export class MultiSigConclusion extends Message<MultiSigConclusion> {
  /**
   * alert is the alert that this conclusion corresponds to.
   *
   * @generated from field: slinky.alerts.v1.Alert alert = 1;
   */
  alert?: Alert;

  /**
   * oracle_data is the oracle data that this conclusion references.
   *
   * @generated from field: tendermint.abci.ExtendedCommitInfo extended_commit_info = 2;
   */
  extendedCommitInfo?: ExtendedCommitInfo;

  /**
   * signatures is a map of signer -> signature. Where the signature is over
   * Alert.UID, PriceBound, the marshalled ExtendedCommitInfo, and status.
   *
   * @generated from field: repeated slinky.alerts.v1.Signature signatures = 3;
   */
  signatures: Signature[] = [];

  /**
   * price-bound is the price bound of the currency-pair off-chain for the
   * designated time-range.
   *
   * @generated from field: slinky.alerts.v1.PriceBound price_bound = 4;
   */
  priceBound?: PriceBound;

  /**
   * status is the status of the conclusion.
   *
   * @generated from field: bool status = 5;
   */
  status = false;

  /**
   * CurrencyPairID is the ID of the currency-pair that this conclusion
   * corresponds to.
   *
   * @generated from field: uint64 currency_pair_i_d = 6;
   */
  currencyPairID = protoInt64.zero;

  constructor(data?: PartialMessage<MultiSigConclusion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.MultiSigConclusion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alert", kind: "message", T: Alert },
    { no: 2, name: "extended_commit_info", kind: "message", T: ExtendedCommitInfo },
    { no: 3, name: "signatures", kind: "message", T: Signature, repeated: true },
    { no: 4, name: "price_bound", kind: "message", T: PriceBound },
    { no: 5, name: "status", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "currency_pair_i_d", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultiSigConclusion {
    return new MultiSigConclusion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultiSigConclusion {
    return new MultiSigConclusion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultiSigConclusion {
    return new MultiSigConclusion().fromJsonString(jsonString, options);
  }

  static equals(a: MultiSigConclusion | PlainMessage<MultiSigConclusion> | undefined, b: MultiSigConclusion | PlainMessage<MultiSigConclusion> | undefined): boolean {
    return proto3.util.equals(MultiSigConclusion, a, b);
  }
}

/**
 * MultiSigConclusionVerificationParams defines the parameters necessary to
 * verify a MultiSigConclusion. It contains a map between signer and public key.
 * Notice, the public-key (value) are the base-64 encoded bytes of the public
 * key. And the signer (key) is the bech32 encoded address of the signer.
 * Notice, all public keys must be secp256 keys.
 *
 * @generated from message slinky.alerts.v1.MultiSigConclusionVerificationParams
 */
export class MultiSigConclusionVerificationParams extends Message<MultiSigConclusionVerificationParams> {
  /**
   * signers is a map of signer -> public key.
   *
   * @generated from field: repeated google.protobuf.Any signers = 1;
   */
  signers: Any[] = [];

  constructor(data?: PartialMessage<MultiSigConclusionVerificationParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.MultiSigConclusionVerificationParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signers", kind: "message", T: Any, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultiSigConclusionVerificationParams {
    return new MultiSigConclusionVerificationParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultiSigConclusionVerificationParams {
    return new MultiSigConclusionVerificationParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultiSigConclusionVerificationParams {
    return new MultiSigConclusionVerificationParams().fromJsonString(jsonString, options);
  }

  static equals(a: MultiSigConclusionVerificationParams | PlainMessage<MultiSigConclusionVerificationParams> | undefined, b: MultiSigConclusionVerificationParams | PlainMessage<MultiSigConclusionVerificationParams> | undefined): boolean {
    return proto3.util.equals(MultiSigConclusionVerificationParams, a, b);
  }
}

/**
 * PriceBound represents the bounds of the price of a currency-pair off chain
 * for a designated time-range
 *
 * @generated from message slinky.alerts.v1.PriceBound
 */
export class PriceBound extends Message<PriceBound> {
  /**
   * @generated from field: string high = 1;
   */
  high = "";

  /**
   * @generated from field: string low = 2;
   */
  low = "";

  constructor(data?: PartialMessage<PriceBound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.alerts.v1.PriceBound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "high", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "low", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceBound {
    return new PriceBound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceBound {
    return new PriceBound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceBound {
    return new PriceBound().fromJsonString(jsonString, options);
  }

  static equals(a: PriceBound | PlainMessage<PriceBound> | undefined, b: PriceBound | PlainMessage<PriceBound> | undefined): boolean {
    return proto3.util.equals(PriceBound, a, b);
  }
}

