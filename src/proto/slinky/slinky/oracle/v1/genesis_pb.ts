// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file slinky/oracle/v1/genesis.proto (package slinky.oracle.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { CurrencyPair } from "../../types/v1/currency_pair_pb.js";

/**
 * QuotePrice is the representation of the aggregated prices for a CurrencyPair,
 * where price represents the price of Base in terms of Quote
 *
 * @generated from message slinky.oracle.v1.QuotePrice
 */
export class QuotePrice extends Message<QuotePrice> {
  /**
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * BlockTimestamp tracks the block height associated with this price update.
   * We include block timestamp alongside the price to ensure that smart
   * contracts and applications are not utilizing stale oracle prices
   *
   * @generated from field: google.protobuf.Timestamp block_timestamp = 2;
   */
  blockTimestamp?: Timestamp;

  /**
   * BlockHeight is height of block mentioned above
   *
   * @generated from field: uint64 block_height = 3;
   */
  blockHeight = protoInt64.zero;

  constructor(data?: PartialMessage<QuotePrice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.oracle.v1.QuotePrice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "block_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuotePrice {
    return new QuotePrice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuotePrice {
    return new QuotePrice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuotePrice {
    return new QuotePrice().fromJsonString(jsonString, options);
  }

  static equals(a: QuotePrice | PlainMessage<QuotePrice> | undefined, b: QuotePrice | PlainMessage<QuotePrice> | undefined): boolean {
    return proto3.util.equals(QuotePrice, a, b);
  }
}

/**
 * CurrencyPairState represents the stateful information tracked by the x/oracle
 * module per-currency-pair.
 *
 * @generated from message slinky.oracle.v1.CurrencyPairState
 */
export class CurrencyPairState extends Message<CurrencyPairState> {
  /**
   * QuotePrice is the latest price for a currency-pair, notice this value can
   * be null in the case that no price exists for the currency-pair
   *
   * @generated from field: slinky.oracle.v1.QuotePrice price = 1;
   */
  price?: QuotePrice;

  /**
   * Nonce is the number of updates this currency-pair has received
   *
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  /**
   * ID is the ID of the CurrencyPair
   *
   * @generated from field: uint64 id = 3;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<CurrencyPairState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.oracle.v1.CurrencyPairState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "message", T: QuotePrice },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrencyPairState {
    return new CurrencyPairState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrencyPairState {
    return new CurrencyPairState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrencyPairState {
    return new CurrencyPairState().fromJsonString(jsonString, options);
  }

  static equals(a: CurrencyPairState | PlainMessage<CurrencyPairState> | undefined, b: CurrencyPairState | PlainMessage<CurrencyPairState> | undefined): boolean {
    return proto3.util.equals(CurrencyPairState, a, b);
  }
}

/**
 * CurrencyPairGenesis is the information necessary for initialization of a
 * CurrencyPair.
 *
 * @generated from message slinky.oracle.v1.CurrencyPairGenesis
 */
export class CurrencyPairGenesis extends Message<CurrencyPairGenesis> {
  /**
   * The CurrencyPair to be added to module state
   *
   * @generated from field: slinky.types.v1.CurrencyPair currency_pair = 1;
   */
  currencyPair?: CurrencyPair;

  /**
   * A genesis price if one exists (note this will be empty, unless it results
   * from forking the state of this module)
   *
   * @generated from field: slinky.oracle.v1.QuotePrice currency_pair_price = 2;
   */
  currencyPairPrice?: QuotePrice;

  /**
   * nonce is the nonce (number of updates) for the CP (same case as above,
   * likely 0 unless it results from fork of module)
   *
   * @generated from field: uint64 nonce = 3;
   */
  nonce = protoInt64.zero;

  /**
   * id is the ID of the CurrencyPair
   *
   * @generated from field: uint64 id = 4;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<CurrencyPairGenesis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.oracle.v1.CurrencyPairGenesis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_pair", kind: "message", T: CurrencyPair },
    { no: 2, name: "currency_pair_price", kind: "message", T: QuotePrice },
    { no: 3, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrencyPairGenesis {
    return new CurrencyPairGenesis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrencyPairGenesis {
    return new CurrencyPairGenesis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrencyPairGenesis {
    return new CurrencyPairGenesis().fromJsonString(jsonString, options);
  }

  static equals(a: CurrencyPairGenesis | PlainMessage<CurrencyPairGenesis> | undefined, b: CurrencyPairGenesis | PlainMessage<CurrencyPairGenesis> | undefined): boolean {
    return proto3.util.equals(CurrencyPairGenesis, a, b);
  }
}

/**
 * GenesisState is the genesis-state for the x/oracle module, it takes a set of
 * predefined CurrencyPairGeneses
 *
 * @generated from message slinky.oracle.v1.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * CurrencyPairGenesis is the set of CurrencyPairGeneses for the module. I.e
   * the starting set of CurrencyPairs for the module + information regarding
   * their latest update.
   *
   * @generated from field: repeated slinky.oracle.v1.CurrencyPairGenesis currency_pair_genesis = 1;
   */
  currencyPairGenesis: CurrencyPairGenesis[] = [];

  /**
   * NextID is the next ID to be used for a CurrencyPair
   *
   * @generated from field: uint64 next_id = 2;
   */
  nextId = protoInt64.zero;

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.oracle.v1.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_pair_genesis", kind: "message", T: CurrencyPairGenesis, repeated: true },
    { no: 2, name: "next_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

