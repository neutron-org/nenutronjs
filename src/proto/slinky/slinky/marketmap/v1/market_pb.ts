// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file slinky/marketmap/v1/market.proto (package slinky.marketmap.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { CurrencyPair } from "../../types/v1/currency_pair_pb.js";

/**
 * AggregationType is the type of aggregation that will be used to aggregate the
 * prices of the tickers.
 *
 * @generated from enum slinky.marketmap.v1.AggregationType
 */
export enum AggregationType {
  /**
   * UNKOWN_AGGREGATION_TYPE is the default value for the aggregation type.
   *
   * @generated from enum value: UNKNOWN_AGGREGATION_TYPE = 0;
   */
  UNKNOWN_AGGREGATION_TYPE = 0,

  /**
   * IndexPriceAggregation is the type of aggregation that will be used to
   * aggregate the prices of the tickers. Specifically, this converts the prices
   * either directly or using the index price to a common currency pair.
   *
   * @generated from enum value: INDEX_PRICE_AGGREGATION = 1;
   */
  INDEX_PRICE_AGGREGATION = 1,

  /**
   * StandardMedianAggregation is the type of aggregation that will be used to
   * aggregate the prices of the tickers. Specifically, this converts the prices
   * to a common currency pair and then takes the median of the prices. No
   * conversions are done if the prices are already in the common currency pair.
   *
   * @generated from enum value: STANDARD_MEDIAN_AGGREGATION = 2;
   */
  STANDARD_MEDIAN_AGGREGATION = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AggregationType)
proto3.util.setEnumType(AggregationType, "slinky.marketmap.v1.AggregationType", [
  { no: 0, name: "UNKNOWN_AGGREGATION_TYPE" },
  { no: 1, name: "INDEX_PRICE_AGGREGATION" },
  { no: 2, name: "STANDARD_MEDIAN_AGGREGATION" },
]);

/**
 * Ticker represents a price feed for a given asset pair i.e. BTC/USD. The price
 * feed is scaled to a number of decimal places and has a minimum number of
 * providers required to consider the ticker valid.
 *
 * @generated from message slinky.marketmap.v1.Ticker
 */
export class Ticker extends Message<Ticker> {
  /**
   * CurrencyPair is the currency pair for this ticker.
   *
   * @generated from field: slinky.types.v1.CurrencyPair currency_pair = 1;
   */
  currencyPair?: CurrencyPair;

  /**
   * Decimals is the number of decimal places for the ticker. The number of
   * decimal places is used to convert the price to a human-readable format.
   *
   * @generated from field: uint64 decimals = 2;
   */
  decimals = protoInt64.zero;

  /**
   * MinProviderCount is the minimum number of providers required to consider
   * the ticker valid.
   *
   * @generated from field: uint64 min_provider_count = 3;
   */
  minProviderCount = protoInt64.zero;

  /**
   * Enabled is the flag that denotes if the Ticker is enabled for price
   * fetching by an oracle.
   *
   * @generated from field: bool enabled = 14;
   */
  enabled = false;

  /**
   * MetadataJSON is a string of JSON that encodes any extra configuration
   * for the given ticker.
   *
   * @generated from field: string metadata_JSON = 15;
   */
  metadataJSON = "";

  constructor(data?: PartialMessage<Ticker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.Ticker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_pair", kind: "message", T: CurrencyPair },
    { no: 2, name: "decimals", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "min_provider_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 14, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "metadata_JSON", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ticker {
    return new Ticker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ticker {
    return new Ticker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ticker {
    return new Ticker().fromJsonString(jsonString, options);
  }

  static equals(a: Ticker | PlainMessage<Ticker> | undefined, b: Ticker | PlainMessage<Ticker> | undefined): boolean {
    return proto3.util.equals(Ticker, a, b);
  }
}

/**
 * @generated from message slinky.marketmap.v1.ProviderConfig
 */
export class ProviderConfig extends Message<ProviderConfig> {
  /**
   * Name corresponds to the name of the provider for which the configuration is
   * being set.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * OffChainTicker is the off-chain representation of the ticker i.e. BTC/USD.
   * The off-chain ticker is unique to a given provider and is used to fetch the
   * price of the ticker from the provider.
   *
   * @generated from field: string off_chain_ticker = 2;
   */
  offChainTicker = "";

  constructor(data?: PartialMessage<ProviderConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.ProviderConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "off_chain_ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProviderConfig {
    return new ProviderConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProviderConfig {
    return new ProviderConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProviderConfig {
    return new ProviderConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ProviderConfig | PlainMessage<ProviderConfig> | undefined, b: ProviderConfig | PlainMessage<ProviderConfig> | undefined): boolean {
    return proto3.util.equals(ProviderConfig, a, b);
  }
}

/**
 * Path is the list of convertable markets that will be used to convert the
 * prices of a set of tickers to a common ticker.
 *
 * @generated from message slinky.marketmap.v1.Path
 */
export class Path extends Message<Path> {
  /**
   * Operations is an ordered list of operations that will be taken. These must
   * be topologically sorted to ensure that the conversion is possible i.e. DAG.
   *
   * @generated from field: repeated slinky.marketmap.v1.Operation operations = 1;
   */
  operations: Operation[] = [];

  constructor(data?: PartialMessage<Path>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.Path";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operations", kind: "message", T: Operation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Path {
    return new Path().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Path {
    return new Path().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Path {
    return new Path().fromJsonString(jsonString, options);
  }

  static equals(a: Path | PlainMessage<Path> | undefined, b: Path | PlainMessage<Path> | undefined): boolean {
    return proto3.util.equals(Path, a, b);
  }
}

/**
 * Operation represents the operation configuration for a given ticker.
 *
 * @generated from message slinky.marketmap.v1.Operation
 */
export class Operation extends Message<Operation> {
  /**
   * CurrencyPair is the on-chain currency pair for this ticker.
   *
   * @generated from field: slinky.types.v1.CurrencyPair currency_pair = 1;
   */
  currencyPair?: CurrencyPair;

  /**
   * Invert is a boolean that indicates whether the price of the ticker should
   * be inverted.
   *
   * @generated from field: bool invert = 2;
   */
  invert = false;

  /**
   * Provider is the name of the provider that will be used to fetch the price
   * of the ticker.
   *
   * @generated from field: string provider = 3;
   */
  provider = "";

  constructor(data?: PartialMessage<Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_pair", kind: "message", T: CurrencyPair },
    { no: 2, name: "invert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation {
    return new Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJsonString(jsonString, options);
  }

  static equals(a: Operation | PlainMessage<Operation> | undefined, b: Operation | PlainMessage<Operation> | undefined): boolean {
    return proto3.util.equals(Operation, a, b);
  }
}

/**
 * @generated from message slinky.marketmap.v1.Paths
 */
export class Paths extends Message<Paths> {
  /**
   * Paths is the list of convertable markets that will be used to convert the
   * prices of a set of tickers to a common ticker.
   *
   * @generated from field: repeated slinky.marketmap.v1.Path paths = 1;
   */
  paths: Path[] = [];

  constructor(data?: PartialMessage<Paths>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.Paths";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "paths", kind: "message", T: Path, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Paths {
    return new Paths().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Paths {
    return new Paths().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Paths {
    return new Paths().fromJsonString(jsonString, options);
  }

  static equals(a: Paths | PlainMessage<Paths> | undefined, b: Paths | PlainMessage<Paths> | undefined): boolean {
    return proto3.util.equals(Paths, a, b);
  }
}

/**
 * @generated from message slinky.marketmap.v1.Providers
 */
export class Providers extends Message<Providers> {
  /**
   * Providers is the list of provider configurations for the given ticker.
   *
   * @generated from field: repeated slinky.marketmap.v1.ProviderConfig providers = 1;
   */
  providers: ProviderConfig[] = [];

  constructor(data?: PartialMessage<Providers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.Providers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "providers", kind: "message", T: ProviderConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Providers {
    return new Providers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Providers {
    return new Providers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Providers {
    return new Providers().fromJsonString(jsonString, options);
  }

  static equals(a: Providers | PlainMessage<Providers> | undefined, b: Providers | PlainMessage<Providers> | undefined): boolean {
    return proto3.util.equals(Providers, a, b);
  }
}

/**
 * @generated from message slinky.marketmap.v1.MarketMap
 */
export class MarketMap extends Message<MarketMap> {
  /**
   * Tickers is the full list of tickers and their associated configurations
   * to be stored on-chain.
   *
   * @generated from field: map<string, slinky.marketmap.v1.Ticker> tickers = 1;
   */
  tickers: { [key: string]: Ticker } = {};

  /**
   * Paths is a map from CurrencyPair to all paths that resolve to that pair
   *
   * @generated from field: map<string, slinky.marketmap.v1.Paths> paths = 2;
   */
  paths: { [key: string]: Paths } = {};

  /**
   * Providers is a map from CurrencyPair to each of to provider-specific
   * configs associated with it.
   *
   * @generated from field: map<string, slinky.marketmap.v1.Providers> providers = 3;
   */
  providers: { [key: string]: Providers } = {};

  /**
   * AggregationType is the type of aggregation that will be used to aggregate
   * the prices of the tickers.
   *
   * @generated from field: slinky.marketmap.v1.AggregationType aggregation_type = 4;
   */
  aggregationType = AggregationType.UNKNOWN_AGGREGATION_TYPE;

  constructor(data?: PartialMessage<MarketMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "slinky.marketmap.v1.MarketMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tickers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Ticker} },
    { no: 2, name: "paths", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Paths} },
    { no: 3, name: "providers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Providers} },
    { no: 4, name: "aggregation_type", kind: "enum", T: proto3.getEnumType(AggregationType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketMap {
    return new MarketMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketMap {
    return new MarketMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketMap {
    return new MarketMap().fromJsonString(jsonString, options);
  }

  static equals(a: MarketMap | PlainMessage<MarketMap> | undefined, b: MarketMap | PlainMessage<MarketMap> | undefined): boolean {
    return proto3.util.equals(MarketMap, a, b);
  }
}

